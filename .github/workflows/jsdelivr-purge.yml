name: Purge jsDelivr Cache

# 工作流触发条件：当向主分支推送时自动执行
# 策略：仅清理已修改的文件，跳过新增文件（新增文件无缓存，无需清理）
on:
  push:
    branches:
      - main
      - master

# 环境变量配置区
env:
  # 需要清理缓存的文件扩展名（使用空格分隔）
  # 仅对这些扩展名的已修改文件执行缓存清理
  TARGET_EXTENSIONS: '.js .css .wasm .json .html .svg .png .jpg .jpeg .gif .webp .ico .woff .woff2 .ttf .eot'
  
  # 是否清理无扩展名文件的缓存（true/false）
  # 建议设为 false，避免清理如 LICENSE、Makefile 等配置文件
  PURGE_NO_EXTENSION: 'false'
  
  # jsDelivr CDN 基础 URL 模板
  CDN_BASE_URL: 'https://cdn.jsdelivr.net/gh/${{ github.repository }}@latest'

jobs:
  purge-cache:
    name: Purge Changed Files Cache
    runs-on: ubuntu-latest
    
    steps:
      # 步骤 1: 检出代码仓库
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整 git 历史以支持可靠的差异对比
      
      # 步骤 2: 获取本次提交中变更的文件列表
      - name: Get Changed Files
        id: changed_files
        run: |
          echo "🔍 检测本次提交中的文件变更..."
          
          # 确定比较的基准提交
          # 优先使用 github.event.before（push 前的 SHA），回退到 HEAD~1
          BASE_SHA="${{ github.event.before }}"
          CURRENT_SHA="${{ github.sha }}"
          
          # 处理首次推送场景（before 为全 0）
          if [[ "$BASE_SHA" =~ ^0+$ ]] || [ -z "$BASE_SHA" ]; then
            echo "⚠️  检测到首次推送，所有文件均为新增，跳过缓存清理"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # 验证 BASE_SHA 是否存在
          if ! git rev-parse --verify "$BASE_SHA" >/dev/null 2>&1; then
            echo "⚠️  基准提交 $BASE_SHA 不存在，尝试使用 HEAD~1"
            BASE_SHA="HEAD~1"
            
            # 再次验证
            if ! git rev-parse --verify "$BASE_SHA" >/dev/null 2>&1; then
              echo "⚠️  HEAD~1 也不存在，可能是首次提交，跳过缓存清理"
              echo "has_changes=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # 使用 git diff 获取**仅修改**的文件列表（排除新增文件）
          # --diff-filter=M: 仅包含修改(Modified)的文件，排除新增(A)、复制(C)、重命名(R)、删除(D)
          CHANGED_FILES=$(git diff --name-only --diff-filter=M "$BASE_SHA" "$CURRENT_SHA" 2>/dev/null || echo "")
          
          # 检查是否有修改的文件
          if [ -z "$CHANGED_FILES" ]; then
            echo "ℹ️  未检测到已修改的文件（新增文件不需要清理缓存）"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "has_changes=true" >> $GITHUB_OUTPUT
          
          # 输出修改的文件列表（用于调试）
          echo "📝 已修改的文件列表 (对比 $BASE_SHA → $CURRENT_SHA):"
          echo "$CHANGED_FILES" | while IFS= read -r file; do
            [ -n "$file" ] && echo "  - $file"
          done
          
          # 将变更文件列表保存到临时文件（使用换行分隔，后续逐行读取）
          echo "$CHANGED_FILES" > /tmp/changed_files.txt
      
      # 步骤 3: 根据配置的扩展名过滤需要清理缓存的文件
      - name: Filter Target Files
        id: filter_files
        if: steps.changed_files.outputs.has_changes == 'true'
        run: |
          echo "🔧 根据配置的扩展名过滤文件..."
          
          # 清空目标文件列表
          > /tmp/target_files.txt
          
          # 使用 while IFS= read 正确处理包含空格的文件名
          while IFS= read -r file; do
            [ -z "$file" ] && continue
            
            # 获取文件名（basename）
            filename=$(basename "$file")
            
            # 检查文件是否包含扩展名（是否有点且点不在开头）
            if [[ "$filename" == *.* ]] && [[ "$filename" != .* ]]; then
              # 提取扩展名（转换为小写）
              ext=$(echo "${filename##*.}" | tr '[:upper:]' '[:lower:]')
              ext_with_dot=".${ext}"
              
              # 检查扩展名是否在配置列表中
              if echo "$TARGET_EXTENSIONS" | grep -q -w "$ext_with_dot"; then
                echo "$file" >> /tmp/target_files.txt
              fi
            else
              # 无扩展名文件：根据配置决定是否清理
              if [ "$PURGE_NO_EXTENSION" = "true" ]; then
                echo "  ℹ️  包含无扩展名文件: $file"
                echo "$file" >> /tmp/target_files.txt
              fi
            fi
          done < /tmp/changed_files.txt
          
          # 检查是否有符合条件的文件（检查文件大小）
          if [ ! -s /tmp/target_files.txt ]; then
            echo "⚠️  没有符合扩展名规则的文件，跳过缓存清理"
            echo "has_target_files=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "has_target_files=true" >> $GITHUB_OUTPUT
          
          # 输出符合条件的文件列表
          echo "✅ 需要清理缓存的文件:"
          while IFS= read -r file; do
            [ -n "$file" ] && echo "  - $file"
          done < /tmp/target_files.txt
      
      # 步骤 4: 生成 jsDelivr CDN URLs
      - name: Generate CDN URLs
        id: generate_urls
        if: steps.filter_files.outputs.has_target_files == 'true'
        run: |
          echo "🌐 生成 jsDelivr CDN URLs..."
          
          # 检查目标文件列表是否存在且不为空
          if [ ! -s /tmp/target_files.txt ]; then
            echo "❌ 目标文件列表为空"
            echo "has_urls=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # 生成 CDN URLs（逗号分隔）
          CDN_URLS=""
          file_count=0
          
          # 使用 while IFS= read 正确处理包含空格的文件名
          while IFS= read -r file; do
            [ -z "$file" ] && continue
            
            file_count=$((file_count + 1))
            
            # URL 编码文件路径（处理空格和特殊字符）
            # 将空格替换为 %20，其他特殊字符保持原样（jsDelivr 支持）
            encoded_file=$(echo "$file" | sed 's/ /%20/g')
            
            # 构建完整的 CDN URL
            url="${CDN_BASE_URL}/${encoded_file}"
            
            # 添加到 URL 列表（使用逗号分隔）
            if [ -z "$CDN_URLS" ]; then
              CDN_URLS="$url"
            else
              CDN_URLS="${CDN_URLS},${url}"
            fi
          done < /tmp/target_files.txt
          
          # 检查是否成功生成 URLs
          echo "📊 处理了 $file_count 个文件"
          if [ -z "$CDN_URLS" ] || [ $file_count -eq 0 ]; then
            echo "❌ 未能生成有效的 CDN URLs（处理文件数: $file_count）"
            echo "has_urls=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "has_urls=true" >> $GITHUB_OUTPUT
          
          # 输出生成的 URLs（用于调试）
          echo "📋 待清理的 CDN URLs:"
          echo "$CDN_URLS" | tr ',' '\n' | while IFS= read -r url; do
            [ -n "$url" ] && echo "  - $url"
          done
          
          # 保存 URLs 到输出
          echo "urls=$CDN_URLS" >> $GITHUB_OUTPUT
      
      # 步骤 5: 执行 jsDelivr 缓存清理
      - name: Purge jsDelivr Cache
        if: steps.generate_urls.outputs.has_urls == 'true'
        uses: egad13/purge-jsdelivr-cache@v1
        with:
          url: ${{ steps.generate_urls.outputs.urls }}
          attempts: 3  # 失败重试次数
      
      # 步骤 6: 输出执行结果摘要
      - name: Summary
        if: always()
        run: |
          echo "## 🎯 jsDelivr 缓存清理执行摘要" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **策略**: 仅清理已修改的文件，跳过新增文件" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.changed_files.outputs.has_changes }}" != "true" ]; then
            echo "ℹ️ **结果**: 未检测到已修改的文件（新增文件不需要清理缓存）" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.filter_files.outputs.has_target_files }}" != "true" ]; then
            echo "⚠️ **结果**: 已修改的文件不符合扩展名规则" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**配置的扩展名**: \`$TARGET_EXTENSIONS\`" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.generate_urls.outputs.has_urls }}" != "true" ]; then
            echo "❌ **结果**: 未能生成有效的 CDN URLs" >> $GITHUB_STEP_SUMMARY
          else
            echo "✅ **结果**: 缓存清理已完成" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**清理的 URLs**:" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "${{ steps.generate_urls.outputs.urls }}" | tr ',' '\n' >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
